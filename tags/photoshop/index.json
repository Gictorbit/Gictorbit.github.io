[{"content":"همینطور که در قسمت های قبل دیدیم اگر کامپایلر رو به یک جعبه تشبیه کنیم که یک برنامه مبدا (source program) رو به یک برنامه معادل با کارکرد یکسان تبدیل میکند اگر کمی این جعبه رو باز کنیم می بینیم که تمام مراحل کامپایلر از دو قسمت کلی تشکیل شده :\n مراحل تحلیل | analysis مراحل ساخت | synthesis  مراحل تحلیل (analysis) مرحله تحلیل برنامه مبدا رو به اجزاء اصلی تقسیم میکند و ساختار گرامری رو در برنامه مبدا اعمال میکند سپس از روی این ساختار کد میانی (intermediate code) معادل رو تولید میکند در این مرحله کد تحلیل می شود و اگر خطا یا اروری وجود داشته باشد پیام های اخطار رو چاپ میکند تا کاربر کد خودش رو اصلاح بکند.\nهم چنین در مرحله تحلیل اطلاعاتی درباره برنامه مبدا استخراج میشود و در یک ساختمان داده ای به نام جدول نماد symbol table ذخیره می شود که به همراه کد میانی تولید شده به مرحله ساخت پاس داده می شوند\nمراحل ساخت (synthesis) در بخش ساخت، از کد میانی که مرحله قبل تولید شده به همراه اطلاعات جدول نماد که خروجی مراحل تحلیل هستند یک برنامه نهایی (target program) ایجاد میشود.\n به مراحل تحلیل اغلب  Front End یا بخش جلویی کامپایلر گفته میشود\nو به مراحل ساخت Back end یا عقب کامپایلر می گویند\n اگر فرایند کامپایل رو دقیق تر بررسی کنیم می بینیم که این فرایند از فاز های پشت سرهم تشکیل شده و هر فاز کد مبدا رو بررسی میکند و به فاز بعد ارائه میکند برای مثال یک نمونه از تجزیه فاز های کامپایلر رو در شکل زیر می بینید\nفاز های کامپایلر: Phases of a compiler   جدول علائم یا همان symbol table که اطلاعاتی درباره کل برنامه مبدا رو ذخیره میکند توسط همه ی فاز های کامپایل استفاده میشود و همه فاز ها به آن دسترسی دارند در کنار جدول علائم یک بخش دیگر به نام کنترل کننده خطا یا error handler هم وجود دارد و فاز ها از آن استفاده می کنند\nهم چنین بعضی از کامپایلر ها یک فاز بهینه سازی بین backend و frontend دارند که کد میانی تولید شده رو بهینه سازی میکند و این به backend کمک میکند تا برنامه نهایی بهینه تر باشد\nتحلیل گر لغوی (Lexical Analyser) به اولین فاز کامپایلر تحلیل لغوی یا اسکن scanning میگویند تحلیلگر لغت، تمام کاراکتر های برنامه منبع را می خواند و به صورت رشته های معنادار گروه بندی می کند به این رشته ها lexeme می گویند برای هر lexeme تحلیل گر لغت یک توکن Token به فرم زیر تولید می کند که این توکن به فاز بعدی یعنی تحلیلگر نحوی تحویل داده خواهد شد.\n(token name , attribute value) (مقدار توکن ، نام توکن) \nانواع توکن | Token اولین جزء توکن token name یک نماد هست که به نوع توکن اشاره می کند و در analysis syntax یا تحلیلگر نحوی استفاده می شود. برای توضیح انواع توکن تکه کد زیر رو بررسی میکنیم و توکن های اون رو شناسایی می کنیم\n1 2 3 4 5 6 7 8 9  int main(){ int number = 5; if (number\u0026gt;10){ result=number*60; }else{ printf(\u0026#34;Error\u0026#34;); } return 0; }   1- ⠀key word⠀\nتمام دستورات برنامه نویسی که توسط زبان رزرو شده اند جزء این دسته قرار می گیرند\n[ if , int , else , printf , return]\n2- ⠀Identifier | id⠀\nهر اسمی که توسط برنامه نویس تعریف بشود مثل اسم متغیر ، اسم تابع، اسم کلاس ، نام ماکرو ، اسم یک ساختمان داده ، اسم آرایه و \u0026hellip;\n[ number , result , main]\n3- ‎‎‏‏‎‎⠀operator⠀\nعملگرها نوع دیگر توکن هستند که شامل عملگر های زبان برنامه نویسی مثل عملگر های ریاضی و انتساب می شود.\n[ * , \u0026gt; , = ]\n4- ⠀Number⠀\nمقادیر عددی که در برنامه های خود مینویسیم هم نوع دیگر توکن به حساب میاد\n[ 5 , 10 , 60 , 0 ]\n5- ⠀symbol⠀\nهمچنین علائم جز جدا نشدنی برنامه های ما هستن مثل ; یا پرانتزها و کرلی براکت و.. که در مثال بالا علائم ما مقادیر زیر هستند.\n[ ; , { , } , ( , ) ]\n6-⠀string⠀\nآخرین نوع توکن رشته ها یا آرایه ای از کاراکترها هستند که معمولا بین دو \u0026quot; قرار میگیرند\n[ \u0026quot;Error\u0026quot; ]\nتشخیص Token برای تشخیص دادن الگوی توکن های موجود در برنامه مبدا، از علم نظریه زبان ها و زبان های منظم در کامپایلر استفاده می شود\nجزء دوم توکن attribute-value هست که به موجودی برای این توکن در جدول علائم یا symbol table اشاره می کند همچنین برای semantic analysis یا تحلیل معنایی و تولید کد اسمبلی به اطلاعاتی که در symbol table ذخیره شده اند نیاز داریم برای مثال فرض کنید در برنامه مبدا دستور زیر وجود دارد مراحل کامپایل این دستور رو مرور می کنیم\nposition = initial + rate * 60 همینطور که مشخص هست این دستور شامل 7 گروه کاراکتر معنا دار یا 7 lexeme هست هر کدام رو به صورت جداگانه بررسی می کنیم\n1- متغیر position به عنوان یک lexeme توسط کامپایلر شناسایی می شود و از آنجا که یک توکن از نوع identifier هست به توکن  \u0026lt; 1 , id \u0026gt; نگاشت میشود. id اشاره به نوع توکن دارد و 1 اشاره به ردیف اول symbol table دارد که اطلاعات مربوط این lexeme مثل اسم متغیر و نوع و\u0026hellip; در آن ذخیره شده است.\n2- نماد مساوی = هم کاراکتر معنا دار و lexeme دوم در دستور بالا هست و به توکن \u0026lt; = \u0026gt; نگاشت می شود اما از آنجا که نوع توکن عملگر هست نیازی به attribute ندارد. همچنین میتوانیم برای عملگر مساوی از نام assign استفاده کنیم ولی برای راحتی کار، از خود کاراکتر مساوری به عنوان نام توکن استفاده می کنیم.\n3- همینطور initial یه عنوان یک lexeme به توکن \u0026lt; 2 , id \u0026gt; نگاشت می شود و 2 به موجود دوم symbol table اشاره می کند که اطلاعات متغیر initial رو ذخیره کرده است.\n4- عملگر + هم یک lexeme بعدی هست و به توکن \u0026lt; + \u0026gt; نگاشت می شود.\n5- متغیر rate هم به عنوان lexeme پنجم به توکن \u0026lt; 3 , id \u0026gt; نگاشت می شود و 3 به خانه سوم symbol table اشاره می کند که اطلاعات متغیر rate در آن ذخیره شده است.\n6- عملگر * هم به عنوان یک lexeme به توکن \u0026lt; * \u0026gt; map (نگاشت) می شود.\n7- عدد 60 آخرین lexeme دستور بالا به توکن \u0026lt;60\u0026gt; نگاشت می شود.\nکاراکتر های خالی که بین lexeme ها فاصله ایجاد کرده اند توسط تحلیلگر لغوی نادیده گرفته می شوند دستور انتساب یا (assignment statement) بالا بعد از تحلیل لغوی به ترتیبی از توکن ها تبدیل می شود\n\u0026lt;id,1\u0026gt; \u0026lt; = \u0026gt; \u0026lt;id,2\u0026gt; \u0026lt; + \u0026gt; \u0026lt;id,3\u0026gt; \u0026lt; * \u0026gt; \u0026lt;60\u0026gt; در مثال ما نام های = و + و* برای راحتی در توکن ها به عنوان نام های معادل assignment و addition و multiplication استفاده شده اند.\nکامپایل یک دستور انتساب: translation of an assignment statement  \nتحلیل گر نحوی (Syntax analyser) فاز دوم کامپایلر syntax analyzer یا پارس parsing نام دارد. پارسر parser از اولین جزء توکن که توسط تحلیلگر لغوی تولید شده استفاده می کند و یک درخت از ترتیب قرار گیری توکن ها می سازد به این درخت syntax tree می گویند. این درخت ساختار گرامری یک دستور رو بر اساس توکن ها نشون میده در واقع در این درخت برگ ها عملوند هستند و راس های آن ها عملگر هستند که اولویت عملگر ها رو هم نشان می دهد طبق درخت تولید شده در مثال ما اول باید عدد 60 در توکن \u0026lt;3 , id\u0026gt; که همان متغیر rate هست ضرب شود و نتیجه آن با توکن \u0026lt; 2 , id \u0026gt; که همان initial هست جمع شود و سپس در توکن \u0026lt; 1 , id \u0026gt; که همان position هست ریخته شود تحلیل گر نحوی چک میکند که ترتیب قرار گیری توکن ها درست باشد به عبارتی دیگر دستور ما طبق الگوی از قبل تعریف شده باشد و سپس درخت سینتکس رو به عنوان خروجی به فاز بعدی یعنی تحلیلگر معنایی یا semantic تحویل می دهد. این کار با استفاده از زبان های مستقل از متن انجام می شود\nتحلیلگر معنایی (Semantic Analysis) تحلیلگر معنایی از درخت سینتکس که در مرحله قبل تولید شد و اطلاعات symbol table استفاده می کند تا برنامه مبدا رو از نظر معنایی بررسی کند و اطلاعاتی رو در جدول نماد و درخت ذخیره میکند تا در مرحله بعد از آن برای تولید کد میانی استفاده شود\ntype checking یکی از قسمت های مهم تحلیلگر معناییtype checking هست کامپایلر چک می کند که آیا هر عملگر عملوند مناسب داشته باشد برای مثال هر زبان برنامه نویسی چک میکند که اندیس آرایه از نوع int یا عدد صحیح باشد و اگر عدد اعشاری برای اندیس آرایه استفاده شده باشد خطایی نمایش می دهد گاهی اوقات کامپایلر اجازه میدهد که نوع بعضی متغیر ها به دیگری تبدیل شود مثلا در دستوری که دیدیم فرض کنید position و initial و rate به عنوان متغیر عدد اعشاری تعریف شده باشند از آنجا که عدد 60 از نوع int هست type checker بعد از دیدن عملگر * و بررسی عملوند ها می فهمد که باید یک عدد صحیح (rate) در یک عدد اعشاری ضرب شود در این حالت ممکن است عدد صحیح به عدد اعشاری تبدیل شود در شکل بالا توجه کنید که خروجی تحلیلگر معنایی یک node اضافی برای عملگر inttofloat دارد که مستقیما عدد صحیح یا int رو به عدد اعشاری یا float تبدیل می کند.\nتولید کننده کد میانی (Intermediate Code Generation) در فرایند ترجمه یک برنامه مبدا (source program) به برنامه مقصد (target code) کامپایلر ممکن هست چندین بار یک کد میانی با اشکال مختلف بسازد. درخت سینتکس (syntax tree) در واقع بیان گر کد میانی هست.\nبیشتر کامپایلر ها بعد از تحلیل نحوی و معنایی کد مبدا، یک کد سطح پایین یا کد ماشین شبیه به کد اسمبلی تولید میکنند این کد دو ویژگی مهم باید داشته باشد\n باید تولید آن آسان باشد باید به راحتی به کد ماشین نهایی ترجمه شود  کد های سه آدرسی (three-address code) یک مدل کدمیانی که بررسی خواهیم کرد کد های سه آدرسه و شبیه اسمبلی هستند که هر دستور العمل آنها شامل سه عملوند می باشد هر عملوند می تواند نقش یک رجیستر رو بازی کند. برای مثال خروجی یک تولید کننده کد میانی ( intermediate code generator ) شامل دستورات سه آدرسه در زیر آمده است.\nt1 = inttofloat(60) t2 = id3 * t1 t3 = id2 + t2 id1 = t3 کد سه آدرسه بالا در هر دستور العمل انتساب (assignment) یا (دستور العملی که مقداری رو در یک متغیر ذخیره میکند) حداقل یک عملگر وجود دارد . طبق اولویت عملگر ها در مثال ما دستورات کد میانی از بالا به پایین مرتب می شوند مثلا چون عملگر ضرب اولویت بیشتری نسبت به جمع داره زودتر اجرا میشه در این مرحله کامپایلر نام های موقتی برای نگه داشتن مقادیر حساب شده توسط کد های سه آدرسه تولید می کند همانطور که مشخص هست دستورات اول و آخر کمتر از سه عملوند (operand) دارند\nبهینه سازی کد (code optimization) فاز بهینه ساز کد (code optimizer) تلاش میکند تا کد میانی تولید شده رو بهینه تر کند تا کد ماشین در نهایت نتیجه بهتری داشته باشد برای مثال درصورت تشخیص بهینه ساز ممکن است ترد (thread) جدید برای اجرا به برنامه اضافه کند تا سرعت اجرا بالاتر برود یا مثلا بهینه ساز میفهمد که دستور inttofloat برای تبدیل عدد صحیح به اعشاری جواب یکسان دارد پس برای جلوگیری از اجرای آن در هر بار این عدد رو با 60.0 در زمان کامپایل تعویض میکند در نتیجه محاسبه عدد اعشاری در زمان اجرا انجام نمی شود همینطور بهینه ساز تشخیص میدهد که t3 فقط یکبار استفاده شده تا مقدار خودش رو در id1 بریزد و کد میانی تولید شده میتواند کوتاه تر باشد در نتیجه کد بالا میتواند به شکل زیر کوتاه تر شود\nt1 = id3 * 60.0 id1 = id2 + t1 البته این یک مثال ساده هست برای فهم این موضوع ، واضح هست که کامپایلر ها در بهینه سازی اعمالی که انجام می دهند ممکن هست متفاوت و پیچیده تر باشد\nتولید کننده کد (Code generator) تولید کننده کد به عنوان ورودی کد میانی که توسط برنامه مبداء تولید شده رو تحویل میگیرد و به زبان مقصد نگاشت می کند اگر زبان مقصد زبان ماشین باشد رجیستر ها و خانه های حافظه توسط متغیر های برنامه انتخاب می شوند سپس دستورالعمل های میانی هرکدام ممکن است به چندین دستوالعمل زبان ماشین ترجمه بشوند یکی از مهم ترین وظایف این فاز تخصیص دادن رجیستر ها برای نگهداری متغیر ها هست برای مثال استفاده از رجیستر های R1 و R2 ، در این مرحله کد میانی بهینه شده که از فاز قبلی تحویل گرفته شده به کد اسمبلی زیر تبدیل می شود\n1 2 3 4 5  LDF\tR2,\tid3 MULF\tR2,\tR2,\t#60.0 LDF\tR1,\tid2 ADDF\tR1,\tR1,\tR2 STF\tid1,\tR1   اولین عملوند یا operand هر دستور نشان دهنده مقصد است (یعنی نتیجه این دستور در رجیستری که مشخص شده ریخته میشود مثلا در دستور اول عملوند اول R2 هست یعنی id3 در R2 بارگزاری میشود) حرف F در هر دستور بیان گر این هست که نوع متغیر یک عدد float یا اعشاری هست.\nتوضیح کد اسمبلی بالا کد بالا اول محتوای آدرس id3 رو در رجیستر R2 بارگزاری (load) میکند سپس محتوای رجیستر R2 رو با عدد اعشاری ثابت 60.0 ضرب می کند و نتیجه رو دوباره در رجیستر R2 می ریزد علامت # بیانگر این هست که عدد 60 ثابت هست. سومین دستور متغیر id2 رو در رجیستر R1 بارگزاری می کند و چهارمین دستور رجیستر R1 و R2 (که نتیجه ضرب 60.0 و id3 داخلش هست) رو با هم جمع می کند و نتیجه رو در رجیستر R1 می ریزد و در نهایت مقداری که در رجیستر R1 هست در آدرس id1 ذخیره می شود و میبینید که دستور سطح بالای ما چگونه طی فاز های مختلفی به دستور زبان ماشین و سطح پایینی تبدیل شد البته در این بحث مسائل مهم تخصیص حافظه یا ( storage allocation ) برای متغیر ها نادیده گرفته شده اگر در آینده مبحث رو جلو بردیم می بینیم که سازماندهی حافظه در زمان اجرا بستگی به زبانی که کامپایل شده دارد و همچنین تصمیمات تخصیص دادن حافظه در حین تولید کد میانی یا کد نهایی گرفته می شود.\nمدیریت جدول علائم (Symbol-Table Management) یکی از توابع مهم یک کامپایلر این هست که نام متغیر هایی که در برنامه مبدا استفاده شده اند رو در جایی ثبت کند و اطلاعات ویژگی های مختلف هر نام رو استخراج کند این صفات و ویژگی ها (attributes) ممکن است اطلاعاتی در باره تخصیص حافظه برای نام و نوع و محدوده یا scope یک متغیر (جایی که در برنامه ممکن است از مقدار آن استفاده شود) فراهم کنند.\nدر واقع symbol table یک ساختمان داده شامل یک سط (record) برای هر نام متغیر با ستون هایی (fields) برای ویژگی های (attributes) آن اسم است. هر کامپایلر باید این ساختمان داده رو داشته باشد تا کامپایلر بتواند سریعا به ویژگی و اطلاعات یک متغیر دسترسی پیدا کند\nگروه بندی فاز ها (The Grouping of Phases into Passes) طبق مباحث گذشته دیدیم که یک کامپایلر با فازبندی قسمت های مختلف منطق خود را سازماندهی میکند. فعالیت های مختلف فاز ها در کامپایلر ممکن است به شکل گروهی در یک پاس pass یا دور انجام بشوند مثلا فاز های جلویی (front-end phases) مثل تحلیل لغوی ، نحوی، معنایی و تولید کد میانی ممکن است باهم در قالب یک گروه از فعالیت ها در یک پاس انجام بشوند. بهینه سازی کد ممکن است یک پاس اختیاری باشد بعد از آن فاز های پشتی (back-end phasses) شامل فاز تولید کننده کد (code generation) میتواند در یک پاس دیگر برای ماشین مقصد (target machine) اجرا شود.\nبعضی از مجموعه کامپایلر ها (compiler collections) که دقیق و بهینه ساخته شده اند ، کد میانی طراحی کرده اند که اجازه می دهد فازهای جلویی یا (front-end) برای یک زبان مخصوص به عنوان رابط کاربری از یک back-end برای تولید کد نهایی روی ماشین مقصد استفاده کند با این مجموعه ها ما می توانیم کامپایلر هایی برای زبان های مختلفی تولید کنیم که روی یک ماشین کامپایل بشوند برای مثال در سیستم عامل لینوکس کامپایلری که برای زبان C وجود دارد (GCC (GNU Compiler Collection نام دارد می توانیم front-end یک زبان دیگر با syntax متفاوت رو تولید کنیم و با back-end کامپایلر GCC درکنار هم قرار دهیم با این کار، فاز های جلویی کامپایلر، کد میانی تولید شده را به back-end کامپایلر GCC می دهد و back-end کامپایلر GCC کد زبان ماشین را تولید میکند که قابل اجرا در توزیع های لینوکسی هست.\nهمچنین می توانیم برای ماشین های مختلف چندین back-end رو با front-end یک زبان ترکیب کنیم و کامپایلری بسازیم که برای ماشین های مختلف زبان ماشین قابل اجرا تولید کند.\n","description":"اصول طراحی کامپایلر فصل اول: ساختار کامپایلر (structure of compiler)","id":0,"section":"posts","tags":["طراحی کامپایلر","کامپایلر","ساختار کامپایلر","structure of compiler"],"title":"ساختار کامپایلر | structure of compiler","uri":"http://gictor.ir/posts/compiler/structure-of-compiler/"},{"content":"کامپایلر (compiler) به زبان ساده کامپایلر برنامه ای هست که می تونه یک برنامه که به یک زبان نوشته شده رو بخونه (زبان مبدا یا source language) و به یک برنامه معادل به زبان دیگه (زبان هدف یا target language) ترجمه کنه\nبه شکل زیر دقت کنید یک نقش مهم کامپایلر این هست که هر اروری که در زبان مبدا، طی فرایند ترجمه شناسایی می شود را گزارش کند\n\nاگر برنامه مقصد (target program) یک برنامه زبان ماشین (machine-language) با قابلیت اجرایی (executable) باشه در این صورت می تواند توسط کاربر برای پردازش ورودی ها و تولید خروجی مورد نظر فراخوانی بشه به دیاگرام زیر که اجرای یک target program را نشان می دهد توجه کنید\n\nمفسر (interpreter) یکی دیگه از انواع رایج پردازنده های زبان ( Language Processors ) مفسرها هستند.\nمفسر به جای تولید target program به عنوان یک برنامه ترجمه شده، بر اساس source program و ورودی های کاربر (input) مستقیما عملیات های مشخص شده رو اجرا می کنه شکل زیر یک مفسر را نشان می دهد\n\nمعایب و مزایای compiler و interpreter معمولا کد زبان ماشینی که از برنامه هدف (target program) توسط کامپایلر تولید شده است از مفسری که ورودی ها رو به خروجی نگاشت میکنه سریع تر هست در حالی که یک مفسر در تشخیص دادن ارور ها بهتر عمل میکنه چون source program رو خط به خط تفسیر، و دستور به دستور اجرا می کنه\nکامپایلر های هیبریدی (hybrid compiler) برای مثال زبان جاوا با ادغام دو نوع پردازنده زبان مفسری و کامپایلری از یک ماشین مجازی بهره می برد یک برنامه مبدا (source program) جاوا ممکن است اول به یک زبان میانی به نام بایت کد (byte code) کامپایل شود سپس توسط ماشین مجازی (virtual machine) که همان مفسر جاوا هست خط به خط تفسیر می شود\nفایده این روش این هست که بایت کد هایی که در یک ماشین کامپایل می شوند می توانند در یک ماشین دیگر تفسیر شوند یا شاید در سرار یک شبکه\nالبته برای دستیابی به پردازش سریع تر ورودی ها به خروجی، بعضی از انواع کامپایلر های جاوا به نام just-in-time compilers هستند که قبل از این که برنامه های میانی برای پردازش ورودی ها اجرا بشوند بایت کد را بلافاصله به زبان ماشین (صفر و یک) ترجمه می کنند\n\nپیش پردازشگر preprocessor برای تولید یک target program علاوه بر کامپایلر ممکن است چندین برنامه دیگر نیاز شوند همچنین یک source program ممکن هست به ماژول هایی تقسیم بشه که در فایل های جداگانه ذخیره شده اند.\nبرای تولید برنامه مبدا برنامه مستقل دیگری به نام پیش پردازنده یا preprocessor همه ی ماژول ها رو گرد آوری می کند و یک برنامه مبدا به عنوان خروجی تولید می کند\nعلاوه بر گردآوری فایل ها پیش پردازش گر فایل های کتابخانه ای و یا ماکرو ها (macros) رو شناسایی می کند واونا رو به برنامه مبدا اضافه میکند مثلا در کد زبان سی زیر شاید برنامه ما 10 خط باشد ولی بعد از اضافه شدن کتابخانه ها توسط پیش پردازنده ممکن است برنامه مبدا تولید شده حدود 200 خط بشود\n1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#define PI 3.1415#define circleArea(r) (PI*r*r)int main() { float radius, area; printf(\u0026#34;Enter the radius: \u0026#34;); scanf(\u0026#34;%f\u0026#34;, \u0026amp;radius); area = circleArea(radius); printf(\u0026#34;Area = %.2f\u0026#34;, area); return 0; }   اسمبلر assembler بعد از اون source program اصلاح شده (modified) که خروجی پیش پردازنده بود به کامپایلر سپرده میشه کامپایلر ممکن هست یک برنامه با زبان اسمبلی assembly به عنوان خروجی تولید کند چون برای کامپایلر تولید کردن کد اسمبلی به عنوان خروجی و دیباگ کردن آن آسان تر است و بعد از آن زبان اسمبلی توسط برنامه ای به نام اسمبلر assembler پردازش می شود. اسمبلر برنامه ای است که کد اسمبلی را به کد زبان ماشین یا همان صفر ویک با قابلیت جابجایی یا relocatable (کدی که میتواند در هر کجای حافظه بارگزاری شود) تبدیل میکند\nمنظور از relocateble چیست؟ همینطور که خواندیم اسمبلر زبان اسمبلی رو به زبان ماشین قابل حمل تبدیل میکند برای مثال فرض کنید در ویندوز اسمبلر برای ما یک فایل exe. به عنوان خروجی تولید کند این فایل که در حافظه جانبی(هارد دیسک) قرار داره و میتواند توسط سیستم عامل اجرا بشه هر فایل به صورت بلوک هایی در حافظه جانبی ذخیره شده و آدرس دهی می شوند و آدرس شروع هر فایل از 0 هست هر بلوک که نشان گر یک فایل مثلا exe هست رو فایل زبان ماشین  قابل حمل  گویند.\nاما برای اینکه این فایل زبان ماشین اجرا بشه باید به حافظه اصلی یا (ram) منتقل بشه چرا؟ برای اینکه اولا سرعت رم بیشتر هست و ثانیا فاز اجرا و ذخیره سازی باید از هم دیگر جدا باشند تا مقلا در صورت مشکل در فاز اجرا به برنامه اصلی آسیبی وارد نشه\nبار کننده loader اجرای برنامه ی زبان ماشین توسط سیستم عامل وظیفه لینکر و لودر هست. loader دو وظیفه دارد:\n1- تخصیص حافظه: از آنجایی که بخشی از حافظه توسط سیستم عامل و برنامه های دیگه پر شده لودر باید حافظه اصلی رو بررسی کنه و مکانی از حافظه که فضای کافی برای اجرای برنامه زبان ماشین ما داره رو پیدا کنه\n2- نگاشت آدرس: وقتی برنامه در ram لود شد باید آدرس نسبی که از صفر شروع شده بود به آدرس واقعی (فیزیکی) در حافظه اصلی نگاشت بشه برای مثال در تصویر زیر فرض کنید برنامه از خانه 2000 به بعد در حافظه اصلی لود می شود پس خانه صفر بلوک کد ماشین به جای آدرس صفر به آدرس 2001 نگاشت می شود\n\n منظور از کد ماشین قابل حمل این هست که می تواند در هر مکانی از حافظه اصلی لود بشود ( در هر بار اجرا ممکن است آدرس های فیزیکی نگاشت شده آن متفاوت باشد مثلا دفعه بعد از خانه 3000 حافظه لود بشود)\n فایل های غیر قابل حمل فایل زبان ماشینی که آدرس نسبی ندارد و نمیتونه در هر مکان از حافظه لود بشه رو فایل غیر قابل حمل میگویند (در بلوک های آن به جای آدرس نسبی آدرس فیزیکی مشخص شده) برای مثال در ویندوز فایل های با پسوند com. از این دسته فایل ها هستند\nlinker گاهی اوقات فایل های زبان ماشینی که اجرا می کنیم نیاز دارند که از فایل های دیگری که قبلا در حافظه لود شده اند استفاده کنند شبیه فایل ها وتوابع کتابخانه ای مثلا در ویندوز فایل های DLL یا (dynamic linked library) از این نوع هستند در صورتی که برنامه ما به این کتابخانه ها نیاز داشته باشد یک برنامه به نام linker یک لینک بین برنامه ما و فایل مورد نیاز برقرار می کند.\n سوالات  تفاوت میان کامپایلر و مفسر چیست؟ مزایای یک کامپایلر نسبت به مفسر و مزایای یک مفسر نسبت به کامپایلر چیست؟ در سیستم پردازش زبان مزایای تولید کد اسمبلی به جای کد ماشین توسط کامپایلر چیست؟ به کامپایلری که یک زبان سطح بالا (نزدیک به زبان انسان) را به زبان های سطح بالای دیگر کامپایل می کند مترجم source-to-source گویند. مزایای این که از زبان C به عنوان زبان هدف برای کامپایلر استفاده کنیم چیست؟ وظایف اسمبلر را توضیح دهید؟  ","description":"اصول طراحی کامپایلر فصل اول: بررسی پردازنده های زبان (Language Processors)","id":1,"section":"posts","tags":["طراحی کامپایلر","کامپایلر","پردازنده های زبان","Language Processors"],"title":"پردازنده های زبان | Language Processors","uri":"http://gictor.ir/posts/compiler/language-processors/"},{"content":"امروزه زبان های برنامه نویسی یک ابزار برای نمایش محاسبات به انسان و ماشین هستند و همونطور که می دونیم دنیای ما بیش از پیش به زبان های برنامه نویسی وابستگی داره چون دنیا رو کامپیوتر ها اداره میکنند و نرم افزار هایی که روی آنها در حال اجرا هستند با یک زبان برنامه نویسی نوشته شده اند\nتعریف کامپایلر اما قبل از این که یک برنامه بتونه اجرا بشه اول از همه باید به چیزی که کامپیوتر میتونه اجرا کنه ترجمه بشه به نرم افزار سیستمی که این ترجمه رو انجام میده کامپایلر می گویند\nدر این سری به چگونگی ساختن یک کامپایلر و طراحی اون به طور خلاصه می پردازیم و مفاهیم پایه و ایده هایی که در ساختن یک مترجم برای زبان ها و ماشین های مختلف استفاده میشه رو یاد خواهیم گرفت\nفواید دانستن این علم علاوه بر کامپایلرها، اصول و تکنیک های طراحی کامپایلر در زمینه های دیگر علوم کامپیوتر قابل استفاده هست و یک دانشمند کامپیوتر یا برنامه نویس ممکن است در حرفه خود چندین بار از این مفاهیم استفاده کند\nپیش نیازها همچنین یادگیری نوشتن کامپایلر علوم مختلفی رو در بر میگیره که از مهم ترین آنها میتوان به موارد زیر اشاره کرد\n آشنایی با زبان های برنامه نویسی معماری کامپیوتر و ماشین ها نظریه زبان ها الگوریتم ها مهندسی نرم افزار  مباحث فصل اول در این فصل مقدماتی شکل های مختلف مترجم های زبان (language translators) معرفی می شوند و یک مرور کلی بر یک نمونه کامپایلر خواهیم داشت و درباره مباحث ترند زبان های برنامه نویسی و روند آنها و معماری کامپیوتر و ماشین که کامپایلر ها رو در بر گرفتند بحث خواهیم کرد همچنین نگاهی بر رابطه بین طراحی کامپایلر و علوم کامپیوتر خواهیم داشت\nکامپایلر ها فرا تر از کامپایل یک برنامه کاربرد های دیگری هم دارند که در ادامه به طور خلاصه بررسی می کنیم.\nدر پایان فصل، مفاهیم مهم زبان های برنامه نویسی که برای مطالعه کامپایلر ها نیاز داریم رو به طور خلاصه یاد میگیرم\n","description":"سری درک کامپایلر و اصول طراحی کامپایلر","id":2,"section":"posts","tags":["طراحی کامپایلر","کامپایلر","compiler"],"title":"اصول طراحی کامپایلر","uri":"http://gictor.ir/posts/compiler/introduction/"},{"content":"مقدمه از آنجایی که فتوشاپ یکی از ابزار های قدرتمند ویرایش تصویر هست و افراد زیادی با اون سرو کار دارن و یکی از چیزهایی که بعد از مهاجرت به گنولینوکس باهاش مواجه می شوید نبودن این ابزار برای این سیستم عامل هست اگر چه جایگیزین های خیلی خوب و متن باز مثل Gimp وجود دارند و چه بهتر اگر بتونید از این ابزار ها به جای فتوشاپ در گنو لینوکس استفاده کنید.\nاما برای افرادی مثل من که قبلا فتوشاپ رو یاد گرفتیم شاید یکم یاد گرفتن گیمپ زمان بر و خسته کننده تر باشه همچنین قدرتمند بودن فتوشاپ و وجود آموزش های زیاد تر و رابط کاربری دلچسبش از دلایل دیگری هست که نمیتونید ازش دل بکنید.\nبرای همین تصمیم گرفتم داخل لینوکس نصبش کنم و بعد از کلی آزمون خطا و نصب برنامه های پیش نیاز در کنار wine به نتیجه مطلوب و قابل قبولی رسیدم و برای اینکه روند کار و کانفیگ واین رو سریع تر کنم یک بش اسکریپت نوشتم که این کار رو اتوماتیک برای شما می کنه و درگیر کانفیگ واین و نصب نیازمندی ها نمیشید در ادامه روش نصب با اسکریپت رو مرور می کنیم\nمعرفی Wine خب چون فتوشاپ نسخه لینوکس نداره ما مجبوریم نسخه ویندوز رو در لینوکس با یکم جینگولک بازی نصب کنیم و برای این کار از ابزاری به نام واین یا wine استفاده میکنیم این ابزار یک ویندوز رو داخل لینوکس شبیه سازی میکنه و ما میتونیم فایل exe فتوشاپ رو داخلش نصب کنیم من برای کارایی بهتر فتوشاپ در کنارش dll های مورد نیاز رو قرار میدادم خوشبختانه شما هیچ نیازی به فایل فتوشاپ و یا dll ها ندارید اسکریپت در صورت نیاز همه اجزا رو دانلود میکنه قبل از نصب میتونید wine رو از مدیر بسته توزیع خودتون نصب کنید برای مثال در آرچ لینوکس:\n1  sudo pacman -Syy wine   قابلیت ها  نصب نسخه photoshop cc v19 به حداقل رساندن لگ و کندی با استفاده از نصب dll ها و برنامه های پیش نیاز مثل (msxml,vcrun,atmlib,\u0026hellip;) پشتیبانی از برند های مختلف کارت گرافیک مثل (intel,Nvidia,\u0026hellip;) نصب نسخه اکتیو شده دائم بدون نیاز به شماره سریال و فعال ساز دانلود خودکار فایل فتوشاپ و نرم افزار های مورد نیاز ساختن آیکون دسکتاپ برای لانچر کانفیگ واین به صورت خودکار و پشتیبانی از دارک مود  نصب فتوشاپ برای نصب اول از همه باید اسکریپت رو از گیت هاب کلون کنیم با دستور زیر:\n1  git clone https://github.com/Gictorbit/photoshopCClinux.git   بعد از کلون کردن ریپوزیتوری وارد دایرکتوری میشیم و به اسکریپت قابلیت اجرایی میدیم:\n1 2  cd photoshopCClinux chmod +x PhotoshopSetup.sh   قبل از اجرای اسکریپت از نصب بودن دانلود منیجر aria2 در توزیع خود مطمئن بشید چون اسکریپت برای دانلود فایل ها از این برنامه در پشت صحنه استفاده میکنه مثلا برای نصب از مدیر بسته در آرچ:\n1  sudo pacman -S aria2   اجرای اسکریپت برای اجرای اسکریپت بعد از انجام قدم های بالا فقط کافیه دستور زیر رو در فولدر ریپوزیتوری بزنید و اسکریپت PhotoshopSetup.sh رو اجرا کنید\n1  ./PhotoshopSetup.sh   بعد از اجرا، اسکریپت داده های مورد نیاز رو دانلود و در مسیر /home/$USER/.photoshopCCV19/ نصب می کنه هم چنین فایل های دانلود شده در کش شما ذخیره می شوند تا برای نصب دوباره نیازی به دانلود دوباره نداشته باشید همچنین می تونید از فایل های موجود در مسیر /home/$USER/.cache/photoshopCCV19/ بکاپ بگیرید و دفعات بعدی برای نصب از آنها استفاده کنید\nحذف فتوشاپ برای حذف فتوشاپ فقط کافیه اسکریپت uninstaller.sh رو با دستورات زیر اجرا کنید\n1 2  chmod +x uninstaller.sh ./uninstaller.sh   برای اطلاعات بیشتر به صفحه ریپوزیتوری در گیتهاب مراجعه کنید  ","description":"نصب فتوشاپ cc در گنو لینوکس با استفاده از یک بش اسکریپت","id":3,"section":"posts","tags":["نصب فتوشاپ cc در لینوکس","فتوشاپ cc","photoshop"],"title":"نصب فتوشاپ cc در گنو لینوکس","uri":"http://gictor.ir/posts/gnulinux/photoshop/"},{"content":"استگانوگرافی یا ‍Steganography یک کلمه یونانی و به معنای پنهان نگاری هست این علم باستانی با ورود به عصر تکنولوژی با وجود پیدایش الگوریتم های رمزنگاری و اهمیت امنیت اطلاعات همچنان توجهات رو به خودش جلب کرد ویژگی جالب اون این هست که بعد از رمز نگاری داده، هنوز داده شما معنا دارد و شما با یک مشت عدد و حروف نا مفهوم روبرو نیستید برای اطلاعات بیشتر اینجا رو کلیک کنید.\nsteghide در سال 2003 یک ابزار اوپن سورس با لایسنس GPL بر پایه همین ایده ارائه شد این ابزار می تونه دیتای شما رو داخل پیکسل های یک تصویر یا داخل یک فایل صوتی ذخیره کنه دقت کنید اینجا منظور متا دیتا نیست!\nفرض کنید شما در حال دیدن تصویری هستید که حاوی اطلاعات رمز شده هست یا صدایی رو می شنوید که حاوی پسوردهای شماست مبحث جالبی هستش :)\nاما چطور از این ابزار استفاده کنیم؟ من این ابزار رو داخل توزیع های گنو/لینوکسی تست کردم و در این پست هم روی آرچ لینوکس از اون استفاده می کنیم برای اطلاعات بیشتر به این لینک مراجعه کنید http://steghide.sourceforge.net\nنصب و راه اندازی برای نصب steghide روی گنو لینوکس می تونیم پکیجش رو از مخازن رسمی دانلود کنیم بسته به توزیعی که استفاده می کنیم دستور نصب میتونه متفاوت باشه در آرچ لینوکس با دستور زیر بسته رو نصب می کنیم\nArch debian  sudo pacman -S steghide   sudo apt-get install steghide     'use strict'; var containerId = JSON.parse(\"\\\"bc36b374320d1717\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nبرای دانلود سورس کد یا پکیج برنامه روی download کلیک کنید، همچنین اگر کاربر ویندوز هستید میتونید نسخه GUI برنامه رو نصب کنید\ndownload   steghideui  \nمنطق نرم افزار steghide اول از همه فایل ها رو فشرده می کند و بعد از رمزنگاری با الگوریتم AES که یک الگوریتم رمزنگاری متقارن هست (برای رمزنگاری و رمزگشایی از یک کلید استفاده میکند) درستی مراحل رو چک می کند ولی این نرم افزار محدودیت هایی هم داره که در ادامه اشاره می کنم\nمحدودیت ها  شما می تونید انواع فرمت های فایل رو مخفی کنید اما فایلی که برای پوشش اطلاعات استفاده میکنید (cover file) محدودیت دارد و باید یکی از فرمت های زیر باشه\n[JPEG,BMP,AU,WAV] حجم فایل پوششی باید بزرگتر از فایلی باشه که میخواهید مخفی کنید و باید واقعی باشه (صرفا یک فایل خام با حجم زیاد نباشه) ما نمی تونیم یک فایل بزرگ مثلا 200 مگابایتی رو در یک عکس مخفی کنیم و ایده خوبی نیست شما کجا یک عکس با حجم 200 مگابایت دیدید؟ اگرچه فایل های WAV می توانند حجم های بزرگی داشته باشند بنابراین برای فایل های بزرگتر گزینه مناسب تری هستند  دستورات steghide برای مخفی کردن و آشکار کردن اطلاعات ما از دو دسته دستوراتembed و extract استفاده میکنیم\nمخفی کردن داده ها (embed) فرض کنید من یک فایل password.txt دارم و میخوام اون رو در یک فایل صوتی با پسوند WAV پنهان کنم (همانطور که قبلا گفتم فرمت فایل جاساز هرچیزی میتونه باشه)\nبرای این کار از دستور زیر استفاده می کنیم\n1 2 3 4 5  steghide embed -ef password.txt -cf music.wav Enter passphrase: Re-Enter passphrase: embedding \u0026#34;avatar.jpg\u0026#34; in \u0026#34;IMG_2020.jpg\u0026#34;... done    پارامتر cf- مختصر فایل پوششی (cover file) است پارامتر ef- مختصر فایل جاسازی شده (embed file) است\nبعد از اجرای دستور بالا باید پسورد دلخواه رو وارد کنید و در نهایت فایل پوششی شما پنهان نگاری و فایل password.txt در فایل wav مخفی خواهد شد   باید مسیر فایل های خودتون رو به عنوان آرگومان به پارامتر ها پاس بدید بنابراین از معتبر بودن مسیر فایل ها مطمئن بشید  مثال: مخفی کردن فایل متنی در فایل تصویری\n1  steghide embed -ef password.txt -cf Manic.jpg   مخفی کردن فایل تصویری در فایل تصویری دیگر\n1  steghide embed -ef avatar.png -cf Manic.jpg   آشکار سازی داده پنهان شده (extract) حال فرض کنید ما یک فایل تصویری پنهان نگاری شده Manic.jpg داریم و میخواهیم فایل اصلی که ‍‍password.txt هست رو استخراج کنیم برای این کار باید از دستور زیر استفاده کنیم\n1 2 3 4  steghide extract -sf Manic.jpg Enter passphrase: wrote extracted data to \u0026#34;password.txt\u0026#34;.   بعد از اجرای دستور باید پسوردی که قبلا برای مخفی کردن فایل استفاده کردیم رو وارد کنیم و بعد از اون فایل مخفی شده استخراج میشه و در دایرکتوری فعلی نوشته میشه\nچک کردن فایل برای بررسی کردن این که آیا یک فایل پنهان نگاری شده یا نه می تونیم از دستور زیر استفاده کنیم\n1  steghide info Manic.jpg   تا اینجا تقریبا همه دستورات مهم رو دیدیم برای این که مطلب طولانی نشه از توضیح دادن پارامتر های دیگر این ابزار صرف نظر میکنم اما شما می تونید برای استفاده از قابلیت های دیگر از طریق دستور زیر به راهنمای این ابزار دسترسی داشته باشید\n1  man steghide   ","description":"استگانوگرافی با استفاده از ابزار steghide","id":4,"section":"posts","tags":["مخفی کردن داده در تصویر","استگانوگرافی","steghide"],"title":"مخفی کردن داده ها در تصویر و صوت","uri":"http://gictor.ir/posts/gnulinux/steghide/"},{"content":"شاید برای شما هم اتفاق افتاده باشه که وسط کار کردن در ترمینال خودتون به فایلی برخورد کنید و بخواهید اون رو با دیگران به اشتراک بذارید یک روش مرسوم این هست که مرورگر رو باز کنید و با استفاده از یک سایت اشتراک گذاری فایل یا سرویس های معروف مثل دراپ باکس یا گوگل درایو و\u0026hellip; فایل خودتون رو آپلود کنید یا در کم دردسر ترین حالت با شبکه های اجتماعی اون فایل رو به اشتراک بگذارید اما یک روش ساده تر و سریع تر هم وجود داره که در ادامه اون رو بررسی میکنیم\ntransfer.sh این راه حل سریع و ساده برای اشتراک گذاری فایل ها از کامند لاین یا ترمینال استفاده از transfer.sh هست فقط کافیه فایلی که میخواهید رو با دستورات زیر آپلود کنید و در نتیجه لینک اشتراک گذاری فایل به عنوان خروجی چاپ میشه\nقابلیت ها  دسترسی از خط فرمان رایگان بودن آپلود فایل تا حجم 10GB ذخیره فایل ها تا 14 روز رمزنگاری فایل ها  آپلود فایل با curl یک ابزار معروف برای انتقال دیتا بین سرور و کلاینت با پروتکل های مختلف curl هست میتونیم برای آپلود فایل ازش استفاده کنیم\nقبل از هرچیز از نصب بودن curl در سیستم عامل خود مطمئن باشید 1  \u0026gt; curl --upload-file ./hello.txt https://transfer.sh/hello.txt   https://transfer.sh/66nb8/hello.txt با اجرای دستور بالا در صورت موفقیت آمیز بودن لینک دانلود به عنوان خروجی دستور نمایش داده میشه\n پارامتر upload-file-- برای آپلود فایل در curl استفاده میشه آرگومان hello.txt/. در واقع مسیر فایلی هست که قصد اشتراک گذاری اون رو داریم و باید حتما وجود داشته باشه آرگومان سوم لینک سروری هست که میخواهیم فایل رو داخلش آپلود کنیم که در مثال ما https://transfer.sh هست اما باید در ادامه اسم فایل رو که hello.txt هست اضافه کنیم  تعریف alias اما همینطور که واضحه تایپ کردن این هم خودش میتونه وقت گیر باشه و شاید موقع آپلود دستور دقیق برای آپلود فایل یادمون نیاد برای همین میتونیم برای این دستور یک Alias تعریف کنیم که کار مارو خیلی آسان خواهد کرد برای این کار تکه کد زیر رو کپی کنید و در انتهای فایل zshrc. یا bashrc. اضافه کنید\nاین دو فایل در شاخه /home/$USER شما هستند و بسته به اینکه zsh دارید یا bash باید یکی از این فایل ها رو ویرایش کنید transfer() { if [ $# -eq 0 ]; then echo -e \u0026quot;No arguments specified. Usage:\\necho transfer /tmp/test.md\\ncat /tmp/test.md | transfer test.md\u0026quot;; return 1; fi tmpfile=$( mktemp -t transferXXX ); if tty -s; then basefile=$(basename \u0026quot;$1\u0026quot; | sed -e 's/[^a-zA-Z0-9._-]/-/g'); curl --progress-bar --upload-file \u0026quot;$1\u0026quot; \u0026quot;https://transfer.sh/$basefile\u0026quot; \u0026gt;\u0026gt; $tmpfile; else curl --progress-bar --upload-file \u0026quot;-\u0026quot; \u0026quot;https://transfer.sh/$1\u0026quot; \u0026gt;\u0026gt; $tmpfile ; fi; cat $tmpfile; rm -f $tmpfile; } بعد از اضافه کردن قطعه کد بالا می تونید با دستور transfer فایل های خودتون رو به سادگی آپلود کنید برای مثال:\n1  transfer hello.txt   دانلود فایل ها برای دانلود فایل در ترمینال هم می تونید با دستور زیر از curl استفاده کنید :\n1  curl https://transfer.sh/66nb8/hello.txt -o hello.txt    آرگومان اول لینک اشتراک گذاری فایل آپلود شده هست پارامتر o-مختصر output است و باید اسم فایل خروجی رو برای دانلود و ذخیره به اون پاس بدیم که در مثال ما hello.txt هست  برای دیدن مثال ها و اطلاعات بیشتر به وبسایت transfer.sh مراجعه کنید  ","description":"اشتراک گذاری فایل ها با transfer.sh","id":5,"section":"posts","tags":["transfer.sh","اشتراک گذاری فایل ها","لینوکس","خط فرمان"],"title":"اشتراک گذاری فایل ها در ترمینال","uri":"http://gictor.ir/posts/gnulinux/share-from-terminal/"},{"content":"مقدمه گوگل درایو یکی دیگر از سرویس های پر کاربرد گوگل هست که با داشتن حساب گوگل می تونید از اون برای ذخیره فایل های خود در اینترنت استفاده کنید اما به صورت پیشفرض هر حساب فقط 15 گیگابایت فضای ذخیره سازی رایگان داره و برای حجم بیشتر باید هزینه پرداخت کنید اما با یک روش جالب میشه این محدودیت رو دور زد در ادامه این روش رو توضیح میدم\nUDS (Unlimited Drive Storage) این روش با استفاده از یک اسکریپت پایتون به نام uds انجام میشه این اسکریپت در واقع فایل های شما رو در قالب داکیومنت یا فایل متنی در سرویس google doc ذخیره میکنه. چیزی که این پست رو جالب میکنه طرز کار این اسکریپت هست که در ادامه میبینیم\nامکانات uds  آپلود فایل ها در گوگل درایو بدون استفاده از 15‍ گیگابایت فضای حساب دانلود فایل های آپلود شده از حساب  منطق  سرویس گوگل داکیومنت برای فایل های متنی که شما ذخیره میکنید فضایی از گوگل درایو کم نمی کند تجزیه فایل های باینری به فایل های متنی با روش کد گذاری base 64 حجم فایل های کد گذاری شده همیشه بیشتر از حجم فایل اصلی هست سرویس گوگل داکیومنت میتونه برای هر فایل متنی میلیون ها کاراکتر ذخیره کنه که حدودا معادل 710 کیلو بایت داده کدگذاری شده با base 64‍ هست  راه اندازی و احراز هویت قبل از اجرای دستورات از نصب بودن git و python در سیستم عامل مطمئن بشید خب برای استفاده از این اسکریپت باید این ریپوزیتوری رو با استفاده از دستور زیر از گیت هاب clone کنیم.\n1  git clone https://github.com/stewartmcgown/uds.git   بعد از اون باید کتابخانه های مورد نیاز رو به کمک فایل requirements.txt موجود در فولدر برنامه نصب کنیم\n1  pip3 install -r requirements.txt   فعال کردن api حساب گوگل برای اینکه برنامه بتونه به گوگل درایو ما دسترسی داشته باشه باید api حساب ما رو داشته باشه برای این کار باید Google\u0026rsquo;s API page رو باز کنیم\nو روی Enable the Drive api کلیک کنید\nبعد از اون ، باید فایل کانفیگ رو که با فرمت json هست دانلود کنیم و در فولدر برنامه با نام client_secret.json ذخیره کنیم\nچون ما در ایران هستیم و سرویس های گوگل تحریم هستن باید از vpn‍ استفاده کنیم راه اندازی اولیه حالا با یکی از دستورات زیر باید برنامه رو برای راه اندازی اولیه اجرا کنیم\nbash bash  1  ./uds.py     1  python3 uds.py       'use strict'; var containerId = JSON.parse(\"\\\"7ee5e343d572678b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nدستورات UDS برای کار با برنامه و ذخیره و دانلود فایل ها باید از آرگومان ها استفاده کنیم\nآپلود فایل برای آپلود فایل باید از دستور push-- استفاده کنیم برای مثال:\n1  ./uds.py --push Ubuntu.Desktop.16.04.iso   Ubuntu.Desktop.16.04.iso will required 543 Docs to store. Created parent folder with ID 1fc6JGpX6vUWiwflL1jBxM1YpuMHFAms8 Successfully Uploaded Ubuntu.Desktop.16.04.iso: [██████████████████████████████] 100% لیست فایل ها برای دیدن لیست فایل های آپلود شده و موجود در درایو باید از دستور list-- استفاده کنیم برای مثال:\n1  ./uds.py --list   Name Size Encoded ID ------------------------ ----- --------- --------------------------------- Ubuntu.Desktop.16.04.iso 810 MB 1.1 GB 1fc6JGpX6vUWiwflL1jBxM1YpuMHFAms8 Ubuntu.Desktop.18.10.iso 1.1 GB 1.3 GB 1RzzVfN9goHMTkM1Hf1FUWUVS_2R3GK7D و برای جستجو در نام فایل ها باید کلمه مورد نظر رو به دستور لیست پاس بدیم:\n1  ./uds.py --list \u0026#34;18\u0026#34;   Name Size Encoded ID ------------------------ ----- --------- --------------------------------- Ubuntu.Desktop.18.10.iso 1.1 GB 1.3 GB 1RzzVfN9goHMTkM1Hf1FUWUVS_2R3GK7D دانلود فایل برای دانلود فایل باید از دستور pull-- استفاده کنیم برای مثال:\n1  ./uds.py --pull 1fc6JGpX6vUWiwflL1jBxM1YpuMHFAms8   Downloaded Ubuntu.Desktop.16.04.iso: [██████████████████████████████] 100% به طور پیشفرض فایل های دانلود شده در فولدر برنامه و دایرکتوری downloads ذخیره میشن\nحذف فایل برای حذف فایل باید از دستور delete-- استفاده کنیم برای مثال:\n1  ./uds.py --delete 1fc6JGpX6vUWiwflL1jBxM1YpuMHFAms8   Deleted 1fc6JGpX6vUWiwflL1jBxM1YpuMHFAms8 منبع: UDS : Unlimited Drive Storage   ","description":"ذخیره نامحدود فایل ها در حساب گوگل","id":6,"section":"posts","tags":["گوگل درایو","python"],"title":"دورزدن محدودیت حجم google drive","uri":"http://gictor.ir/posts/etc/unlimited-google-drive/"},{"content":"گیکتور (gictor) از ادغام دو اسم ویکتور (victor) و گیک (geek) به وجود اومده . اسم مستعار و مورد علاقه من ویکتور است که در لغت به معنای پیروز هست. در حال حاضر که این متن رو می نویسم دانشجوی کارشناسی مهندسی کامپیوتر نرم افزار هستم\nهم چنین علاقه زیادی به کامپیوتر و برنامه نویسی دارم و زمان زیادی صرف یادگیری و کار با این موجود بامزه می کنم و از اونجایی که به این افراد گیک می گویند این نام رو در کنار ویکتور گزاشتم و در نهایت به گیکتور رسیدم\nهدف از ساختن این وبلاگ برای من این هست که مطالب جالب دنیای کامپیوتر رو با بقیه افراد در سطح تخصصی و کاربردی به اشتراک بگذارم همچنین وقتی بخواهم چیزی رو دقیق تر یاد بگیرم سعی میکنم در باره آن بنویسم و در مقاله ای اون رو به خواننده یاد بدم در نتیجه آن موقع خودم بیشتر یاد می گیرم و یادگیری کامپیوتر و دنیای اون برای من خیلی لذت بخشه\nاز اونجایی که به دنیای آزاد متن باز (open source) و گنو/لینوکس (Gnu/Linux) علاقه مندم مطالب این وبلاگ رو با مجوز های آزاد منتشر می کنم\nتا اینجا اسکریپت نویسی رو با پایتون و بش اسکریپت ، شی گرایی رو با جاوا و سرعت و سادگی رو با C حس کردم\n","description":"درباره","id":7,"section":"","tags":null,"title":"درباره","uri":"http://gictor.ir/about/"}]